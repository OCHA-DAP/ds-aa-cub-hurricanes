

## Visualize Options (Forecast + Observational)

## Intro
<!-- markdownlint-disable MD013 -->
Picking out combinations of action (forecast, limited to 3 days) and observational triggers. All trigger combination options have the same overall return period (3.7 years, which is 7 triggering years in the period 2000-2024).

We varied, each for the forecast and the observational:

- wind speed threshold (while storm is in, or is forecast to be in, the ZMA)
- rainfall aggregation (`mean`, or quantiles 50, 80, 90, 95)
- rainfall threshold (two-day sum per pixel during the period that the storm is in, or is forecast to be in, the ZMA, Â±1 day)

And we are looking to optimize for (maximizing):

- Sum of `Total Affected` from EM-DAT for the triggered storms
- Sum of `Amount in US$` from CERF for the triggered storms

```{python}
%load_ext jupyter_black
%load_ext autoreload
%autoreload 2
```

```{python}
import ocha_stratus as stratus
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

from src.datasources.ibtracs import knots2cat
from src.constants import *
```

## Load and process data

### Load Optimization Results

Load the trigger metrics dataset that was generated from the optimization process. This contains all valid trigger combinations that meet the 3.7-year return period requirement, along with their associated impact metrics.

```{python}
blob_name = (
    f"{PROJECT_PREFIX}/processed/fcast_obsv_combined_trigger_metrics.parquet"
)
df_metrics = stratus.load_parquet_from_blob(blob_name)

```

### Load Combined Storm Statistics

Load the comprehensive dataset containing both forecast and observed storm statistics, along with impact data. This will be used to analyze individual storms and create detailed visualizations.

```{python}
blob_name = f"{PROJECT_PREFIX}/processed/fcast_obsv_combined_stats.parquet"
df_stats = stratus.load_parquet_from_blob(blob_name)
```


Calculate the target number of years for CERF-related triggers, accounting for the fact that CERF funding only started in 2006. This adjusts the return period calculation to the available CERF timeframe.

```{python}
### Calculate CERF Target Years
# note that we have to pick a differet number of triggered years for CERF since it only started in 2006
cerf_target_years = int((2024 - 2006 + 1 + 1) / 3.7)
```

Examine the years when CERF funding was provided and their associated funding amounts. This shows that there were 6 CERF years historically, but we can only target up to 5 to maintain the desired return period.

```{python}
### Analyze Historical CERF Years
# we see that there were 6 CERF years, but we can only hope to target up to 5, because otherwise the RP is too low
df_stats[df_stats["cerf"]].groupby("year")[
    "Amount in US$"
].sum().reset_index().sort_values("Amount in US$", ascending=False)
```

Calculate the theoretical maximum CERF funding amount by selecting the top CERF years based on funding amount. This provides a benchmark for evaluating trigger performance.

```{python}
### Calculate Maximum Possible CERF Amount

max_cerf_amount = (
    df_stats[df_stats["cerf"]]
    .groupby("year")["Amount in US$"]
    .sum()
    .reset_index()
    .sort_values("Amount in US$", ascending=False)
    .iloc[:cerf_target_years]
    .sum()["Amount in US$"]
)
```

Set the target number of years (7) for the main impact analysis, corresponding to the 3.7-year return period over the full analysis period from 2000-2024.

```{python}
### Set Target Years for Impact Analysis
target_years = 7
```

Calculate the theoretical maximum total affected population by selecting the top 7 years (target years) with the highest affected populations. This benchmark helps evaluate how well different trigger combinations capture high-impact events.

```{python}
### Calculate Maximum Possible Total Affected
max_total_affected = (
    df_stats.groupby("year")["Total Affected"]
    .sum()
    .reset_index()
    .sort_values("Total Affected", ascending=False)
    .iloc[:target_years]
    .sum()["Total Affected"]
)

max_total_affected
```

### Remove redundant optimizations

Add new metrics to analyze the balance between forecast and observational triggers. These metrics help identify trigger combinations that favor one approach over the other or achieve balance between them.

```{python}
df_metrics["n_years_diff"] = (
    df_metrics["n_years_fcast"] - df_metrics["n_years_obsv"]
)
df_metrics["n_years_diff_abs"] = df_metrics["n_years_diff"].abs()
df_metrics["n_years_total"] = (
    df_metrics["n_years_fcast"] + df_metrics["n_years_obsv"]
)
```

Create a utility function to remove redundant threshold combinations. For any given impact outcome, this function keeps only the lowest threshold values, eliminating trigger combinations that require unnecessarily high thresholds to achieve the same results.

```{python}
### Define Function to Remove Redundant Thresholds
def drop_redundant_thresholds(df, min_cols, id_cols, drop_high=True):
    for min_col in min_cols:
        unique_cols = [x for x in min_cols if x != min_col] + id_cols
        df = df.sort_values(min_col, ascending=drop_high).drop_duplicates(
            subset=unique_cols
        )
    return df
```

Define the different types of columns for organizing the data: threshold columns (wind and rain thresholds), rainfall aggregation method columns, and impact metric columns.

```{python}
### Define Column Categories

thresh_cols = [
    "fcast_wind",
    "fcast_rain_thresh",
    "obsv_wind",
    "obsv_rain_thresh",
]
rain_agg_cols = ["fcast_rain_col", "obsv_rain_col"]
impact_cols = [
    "Total Affected",
    "Total Deaths",
    "Total Damage, Adjusted ('000 US$)",
    "Amount in US$",
]
```

Apply the redundancy removal function to keep only the most efficient trigger combinations - those that achieve the same impact outcomes with the lowest possible thresholds.

```{python}
df_metrics_lowest = drop_redundant_thresholds(
    df_metrics, thresh_cols, impact_cols + rain_agg_cols
)
```



Display the filtered dataset of non-redundant trigger combinations to see the reduced set of viable options.

```{python}
### Display Filtered Results
df_metrics_lowest
```

## Visualization functions

### Define Main Scatter Plot Function

Create a comprehensive plotting function for visualizing trigger combinations. This function creates scatter plots with various filtering options to explore different aspects of the trigger optimization results, including forecast preference, balanced approaches, and theoretical maximum lines.

```{python}
def plot_thresh_scatter(
    x="Total Affected",
    y="Amount in US$",
    color="n_years_diff_abs",
    zorder_rev=True,
    fcast_pref_only=False,
    same_wind=False,
    same_rain_col=False,
    zero_intercept=False,
    df=None,  # override default dataframe
):
    fig, ax = plt.subplots(figsize=(7, 7))

    if df is None:
        df_plot = df_metrics_lowest.copy()
    else:
        df_plot = df.copy()

    if same_wind:
        df_plot = df_plot[df_plot["fcast_wind"] == df_plot["obsv_wind"]]
    if same_rain_col:
        df_plot = df_plot[
            df_plot["fcast_rain_col"]
            == df_plot["obsv_rain_col"].str.removesuffix("_obsv")
        ]

    if fcast_pref_only:
        df_plot = df_plot[df_plot["n_years_diff"] >= 0]

    for n_years_diff_abs, group in df_plot.groupby(color):
        group.plot(
            x=x,
            y=y,
            marker=".",
            linewidth=0,
            alpha=1,
            label=n_years_diff_abs,
            ax=ax,
            zorder=-n_years_diff_abs if zorder_rev else n_years_diff_abs,
        )

    ax.axhline(max_cerf_amount, linestyle="--", color="dodgerblue")
    ax.axvline(max_total_affected, linestyle="--", color="dodgerblue")

    if zero_intercept:
        ax.set_xlim(left=0)
        ax.set_ylim(bottom=0)

    ax.legend(title=color)
    ax.set_ylabel(y)
    ax.set_xlabel(x)
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)

    return fig, ax
```

Calculate the maximum wind speed across both forecast and observed data to set appropriate plot limits.

```{python}
### Get Maximum Wind Speed
max_wind = df_stats[["wind", "wind_obsv"]].max().max()
```

Create a utility function that applies a specific trigger combination to the storm dataset, adding flags to indicate which storms would be triggered by forecast conditions and which by observed conditions.

```{python}
### Define Function to Get Triggered Storms
def get_triggered_storms(index):
    trig = df_metrics_lowest.loc[index]

    df_stats["fcast_trig"] = (df_stats["wind"] >= trig["fcast_wind"]) & (
        df_stats[trig["fcast_rain_col"]] >= trig["fcast_rain_thresh"]
    )

    df_stats["obsv_trig"] = (df_stats["wind_obsv"] >= trig["obsv_wind"]) & (
        df_stats[trig["obsv_rain_col"]] >= trig["obsv_rain_thresh"]
    )

    return df_stats
```


Create a comprehensive plotting function that visualizes individual trigger combinations. This function creates dual plots (forecast vs observed) showing storm positions relative to trigger thresholds, with bubble sizes representing impact levels and colors indicating CERF funding status.

```{python}
def plot_selected_threshs(index, impact_col="Total Affected"):
    trig_color = "gold"
    cerf_color = "crimson"

    fig, axs = plt.subplots(1, 2, figsize=(14, 7), dpi=200)

    trig = df_metrics_lowest.loc[index]
    # print(trig)

    df_stats = get_triggered_storms(index)

    figs = []
    for stage, ax in zip(["fcast", "obsv"], axs):
        other_stage = "fcast" if stage == "obsv" else "obsv"
        wind_col = "wind" if stage == "fcast" else "wind_obsv"
        wind_thresh = trig[f"{stage}_wind"]
        rain_col = trig[f"{stage}_rain_col"]
        rain_thresh = trig[f"{stage}_rain_thresh"]

        ymax = df_stats[rain_col].max() * 1.1
        xmax = max_wind * 1.1

        # fig, ax = plt.subplots(dpi=200, figsize=(7, 7))

        bubble_sizes = df_stats[impact_col].fillna(0)
        bubble_sizes_scaled = bubble_sizes / bubble_sizes.max() * 5000

        ax.scatter(
            df_stats[wind_col],
            df_stats[rain_col],
            s=bubble_sizes_scaled,
            c=df_stats["cerf"].apply(lambda x: cerf_color if x else "grey"),
            alpha=0.3,
            edgecolor="none",
            zorder=1,
        )

        for _, row in df_stats.iterrows():
            triggered = row[f"{stage}_trig"]
            other_triggered = row[f"{other_stage}_trig"]
            ax.annotate(
                row["name"].capitalize() + "\n" + str(row["year"]),
                (row[wind_col], row[rain_col]),
                ha="center",
                va="center",
                fontsize=6,
                color=cerf_color if row["cerf"] == True else "k",
                zorder=10 if row["cerf"] else 9,
                alpha=0.8,
                fontstyle="italic" if other_triggered else "normal",
                fontweight="bold" if triggered else "normal",
            )

        ax.axvline(
            wind_thresh,
            color=trig_color,
            linewidth=0.5,
            zorder=0,
        )
        ax.axhline(
            rain_thresh,
            color=trig_color,
            linewidth=0.5,
            zorder=0,
        )
        ax.add_patch(
            mpatches.Rectangle(
                (wind_thresh, rain_thresh),  # bottom left
                xmax - wind_thresh,  # width
                ymax - rain_thresh,  # height
                facecolor=trig_color,
                alpha=0.1,
                zorder=0,
            )
        )

        for cat_value, cat_name in CAT_LIMITS:
            ax.annotate(
                cat_name + " -",
                (cat_value, 0),
                fontstyle="italic",
                color="grey",
                rotation=90,
                va="top",
                ha="center",
                fontsize=8,
            )

        ax.annotate(
            f" {wind_thresh:.0f} ",
            (wind_thresh, 0),
            color=trig_color,
            rotation=90,
            fontsize=10,
            va="top",
            ha="center",
            fontweight="bold",
        )

        ax.annotate(
            f" {rain_thresh:.1f} ",
            (0, rain_thresh),
            color=trig_color,
            fontsize=10,
            va="center",
            ha="right",
            fontweight="bold",
        )

        if rain_col == "mean":
            rain_agg_str = "mean"
        else:
            q = rain_col.removeprefix("q").removesuffix("_obsv")
            if q == "50":
                rain_agg_str = "median"
            else:
                rain_agg_str = f"{q}th quantile"
        ax.set_ylabel(
            f"Two-day rainfall, {rain_agg_str} over whole country (mm)"
        )
        ax.set_xlabel("\nMax. wind speed while in ZMA (knots)")

        ax.set_xlim(left=0, right=xmax)
        ax.set_ylim(bottom=0, top=ymax)

        ax.set_title(
            "Action (forecast)" if stage == "fcast" else "Observational"
        )

        ax.spines.top.set_visible(False)
        ax.spines.right.set_visible(False)

        # figs.append((fig, ax))
    return fig, axs
```


Create utility functions to format and display storm data in a clear, color-coded format. These functions help categorize CERF funding status and apply appropriate styling to data tables.

```{python}
def set_cerf_str(row):
    if row["cerf"]:
        return "Yes"
    else:
        if row["year"] >= 2006:
            return "No"
        else:
            return "pre-"


def color_df(val):
    if val == "Yes":
        return "background-color: crimson"
    elif val == "No":
        return "background-color: dodgerblue"
    elif val == "Trig.":
        return "background-color: darkorange"
    else:
        return ""
        
```        


Create a comprehensive table display function that shows which storms would be triggered by a specific trigger combination. The function creates a styled table with color coding for CERF status and trigger conditions, along with impact metrics.

```{python}
### Define Detailed Storm Display Function

def disp_selected_threshs(index, impact_col="Total Affected"):
    trig_color = "gold"
    cerf_color = "crimson"

    df_disp = get_triggered_storms(index).copy()

    df_disp["CERF"] = df_disp.apply(set_cerf_str, axis=1)

    df_disp["Storm"] = (
        df_disp["name"].str.capitalize() + " " + df_disp["year"].astype(str)
    )
    df_disp["Action"] = df_disp["fcast_trig"].apply(
        lambda x: "Trig." if x else "No trig."
    )
    df_disp["Obsv."] = df_disp["obsv_trig"].apply(
        lambda x: "Trig." if x else "No trig."
    )

    cols = ["Action", "Obsv.", "CERF", impact_col]
    display(
        df_disp.set_index("Storm")[cols]
        .sort_values(impact_col, ascending=False)
        .style.bar(
            subset=impact_col,
            color="mediumpurple",
            # vmax=500000,
            props="width: 150px;",
        )
        .map(color_df)
        .set_table_styles(
            {
                impact_col: [
                    {"selector": "th", "props": [("text-align", "left")]},
                    {"selector": "td", "props": [("text-align", "left")]},
                ]
            }
        )
        .format({"Total Affected": "{:,}"})
    )
```

## Plot possible combinations

Generate a scatter plot showing the relationship between total affected population and CERF funding amounts for different trigger combinations. The horizontal line at 2.8e7 helps identify high-CERF threshold combinations.

The cluster (option 1 in slides) where the same number of years are triggered with forecast and observational.

```{python}
fig, ax = plot_thresh_scatter(
    "Total Affected", "Amount in US$", "n_years_diff_abs"
)
ax.axhline(2.8e7)
```

## Constrain options

### Filter to Balanced Trigger Combinations

Extract trigger combinations where the forecast and observational approaches trigger the same number of years (difference of 0), representing balanced trigger strategies.

```{python}
df_metrics_balanced = df_metrics_lowest[
    df_metrics_lowest["n_years_diff_abs"] == 0
]
```

### Filter to High-CERF Balanced Combinations

From the balanced combinations, select those with high CERF funding amounts (>=2.8e7) to identify the best balanced trigger options.

```{python}
df_metrics_balanced_high = df_metrics_balanced[
    df_metrics_balanced["Amount in US$"] >= 2.8e7
]
```

Show the filtered set of balanced trigger combinations with high CERF funding potential.

```{python}
df_metrics_balanced_high
```

## Plot Selected Balanced Trigger Combination

Create detailed plots showing how the selected balanced trigger combination (index 60832) would perform, displaying both forecast and observational trigger conditions.

```{python}
plot_selected_threshs(60832)
```

Show which specific storms would be triggered by this balanced combination, with detailed impact metrics and CERF funding information.

```{python}
disp_selected_threshs(60832)
```

## Best Total Affected

Cluster (option 2 in slides) maximizing impact


### Create Scatter Plot for High-Impact Analysis

Generate a scatter plot with a vertical line at 2.7e7 to identify trigger combinations that maximize total affected population.

```{python}
fig, ax = plot_thresh_scatter(
    "Total Affected", "Amount in US$", "n_years_diff_abs"
)
ax.axvline(2.7e7)
```

Select trigger combinations that achieve high total affected population (>=2.7e7) to identify options that maximize humanitarian impact.

```{python}
### Filter for High-Impact Trigger Combinations
df_metrics_high_impact = df_metrics_lowest[
    df_metrics_lowest["Total Affected"] >= 2.7e7
]
```

Show the filtered set of trigger combinations that maximize total affected population.

```{python}
### Display High-Impact Combinations
df_metrics_high_impact
```

### Visualize High-Impact Trigger Combination

Create detailed plots for the selected high-impact trigger combination (index 321743) showing both forecast and observational trigger conditions.

```{python}
plot_selected_threshs(321743)
```

Show which specific storms would be triggered by this high-impact combination, with detailed impact metrics.

```{python}
### Display Storm Details for High-Impact Combination
disp_selected_threshs(321743)
```

## Best CERF amount

Cluster (option 3 in slides) maximizing CERF amount
<!-- #endregion -->

### Create Scatter Plot for High-CERF Analysis

Generate a scatter plot with a horizontal line at 3.3e7 to identify trigger combinations that maximize CERF funding capture.

```{python}
fig, ax = plot_thresh_scatter(
    "Total Affected", "Amount in US$", "n_years_diff_abs"
)
ax.axhline(3.3e7)
```

Select trigger combinations that achieve high CERF funding amounts (>=3.3e7) to identify options that maximize funding capture.

```{python}
### Filter for High-CERF Trigger Combinations
df_metrics_high_cerf = df_metrics_lowest[
    df_metrics_lowest["Amount in US$"] >= 3.3e7
]
```

Show the filtered set of trigger combinations that maximize CERF funding capture.

```{python}
### Display High-CERF Combinations
df_metrics_high_cerf
```

### Visualize High-CERF Trigger Combination

Create detailed plots for the selected high-CERF trigger combination (index 91667) showing both forecast and observational trigger conditions.

```{python}
plot_selected_threshs(91667)
```

Show which specific storms would be triggered by this high-CERF combination, with detailed impact metrics and funding information.

```{python}
### Display Storm Details for High-CERF Combination
disp_selected_threshs(91667)
```

## Two years diff

Looking at that little cluster with a two-year difference. Doesn't look that remarkable, **so left out of slides**

Explore trigger combinations with a two-year difference between forecast and observational triggers, focusing on those with high CERF funding potential.

```{python}
### Analyze Two-Year Difference Combinations
fig, ax = plot_thresh_scatter(
    "Total Affected", "Amount in US$", "n_years_diff_abs"
)
ax.axhline(3.0e7)
```

Select trigger combinations with exactly 2 years difference between forecast and observational triggers, and high CERF funding amounts.

```{python}
### Filter for Two-Year Difference Combinations
df_twoyears = df_metrics_lowest[
    (df_metrics_lowest["n_years_diff_abs"] == 2)
    & (df_metrics_lowest["Amount in US$"] >= 3.0e7)
]
```

```{python}
df_twoyears
```

```{python}
plot_selected_threshs(312998)
```

```{python}
disp_selected_threshs(312998)
```

## One year diff

Small cluster with second-best total impact (option 4 in slides)

```{python}
fig, ax = plot_thresh_scatter(
    "Total Affected", "Amount in US$", "n_years_diff_abs"
)
ax.axvline(2.55e7)
```

```{python}
df_oneyear = df_metrics_lowest[
    (df_metrics_lowest["Total Affected"] >= 2.55e7)
    & (df_metrics_lowest["n_years_diff_abs"] == 1)
]
```

```{python}
df_oneyear
```

```{python}
plot_selected_threshs(321972)
```

```{python}
disp_selected_threshs(321972)
```

## Forecast preference

Looking at how we can tilt probability even more towards forecast - basically just variants of option 1

```{python}
fig, ax = plot_thresh_scatter(
    "Total Affected",
    "Amount in US$",
    "n_years_diff",
    fcast_pref_only=True,
    zorder_rev=False,
)
ax.axhline(2.7e7)
ax.axvline(2.3e7)
```

```{python}
df_fcast_pref = df_metrics_lowest[
    (df_metrics_lowest["Total Affected"] >= 2.3e7)
    & (df_metrics_lowest["Amount in US$"] >= 2.7e7)
    & (df_metrics_lowest["n_years_diff"] >= 0)
]
```

```{python}
df_fcast_pref
```

```{python}
df_fcast_only = df_fcast_pref[df_fcast_pref["n_years_diff"] == 0]
```

```{python}
df_fcast_only
```

```{python}
plot_selected_threshs(25477)  # not sure if worth leaving in book.
```

## Simplified triggers (Phase 1)

Keeping only options with same rainfall aggregation, and same windspeed across forecast and observational

```{python}
df_simplified = df_metrics_lowest[
    (
        df_metrics_lowest["fcast_rain_col"]
        == df_metrics_lowest["obsv_rain_col"].str.removesuffix("_obsv")
    )
    & (df_metrics_lowest["fcast_wind"] == df_metrics_lowest["obsv_wind"])
]
```

```{python}
df_metrics_lowest[
    (df_metrics_lowest["fcast_wind"] == df_metrics_lowest["obsv_wind"])
].sort_values("Total Affected", ascending=False)
```

```{python}
plot_thresh_scatter(
    "Total Affected",
    "Amount in US$",
    color="n_years_diff_abs",
    zero_intercept=True,
)
```

```{python}
plot_thresh_scatter(
    "Total Affected",
    "Amount in US$",
    color="n_years_diff_abs",
    same_wind=True,
    zero_intercept=True,
)
```

```{python}
plot_thresh_scatter(
    "Total Affected",
    "Amount in US$",
    color="n_years_diff_abs",
    same_rain_col=True,
    zero_intercept=True,
)
```

```{python}
plot_thresh_scatter(
    "Total Affected",
    "Amount in US$",
    color="n_years_diff_abs",
    same_rain_col=True,
    same_wind=True,
    zero_intercept=True,
)
```

```{python}
df_simplified.sort_values(
    ["Amount in US$", "Total Affected"],
    ascending=False,
)
```

```{python}
plot_selected_threshs(321844)
```

```{python}
disp_selected_threshs(321844)
```

```{python}
df_metrics_lowest
```

## "Reasonable" triggers (Phase 2)

Trigger combos that meet:

- Same rainfall aggregation, limited to `q50` and `q80`
- Windspeed thresholds within one category of each other
- Forecast wind speed is >= to observational wind speed
- Windspeed thresholds at least Cat. 1 (64 knots)

```{python}
for stage in ["fcast", "obsv"]:
    df_metrics_lowest[f"{stage}_cat"] = df_metrics_lowest[
        f"{stage}_wind"
    ].apply(knots2cat)

df_metrics_lowest["cat_diff"] = (
    df_metrics_lowest["fcast_cat"] - df_metrics_lowest["obsv_cat"]
)

df_metrics_lowest["min_cat"] = df_metrics_lowest[
    ["fcast_cat", "obsv_cat"]
].min(axis=1)
```

```{python}
df_metrics_reasonable = df_metrics_lowest[
    (df_metrics_lowest["cat_diff"].isin([0, 1]))
    & (df_metrics_lowest["min_cat"] >= 1)
    & (
        df_metrics_lowest["fcast_rain_col"]
        == df_metrics_lowest["obsv_rain_col"].str.removesuffix("_obsv")
    )
    & (df_metrics_lowest["fcast_rain_col"].isin(["q50", "q80"]))
].copy()
```

```{python}
len(df_metrics_reasonable)
```

```{python}
fig, ax = plot_thresh_scatter(
    df=df_metrics_reasonable,
    zero_intercept=True,
    # color="n_years_diff",
    # zorder_rev=False,
)
```

```{python}
fig, ax = plot_thresh_scatter(
    df=df_metrics_reasonable,
    zero_intercept=True,
    # color="n_years_diff",
    # zorder_rev=False,
)
ax.axhline(2.8e7)
ax.axvline(2.55e7)
```

```{python}
df_metrics_reasonable_bestcerf = df_metrics_reasonable[
    df_metrics_reasonable["Amount in US$"] >= 2.8e7
]
```

```{python}
df_metrics_reasonable_bestcerf[
    df_metrics_reasonable_bestcerf["n_years_diff"] == 1
]
```

### Option 1b

Maximizing CERF, taking closest to balanced (`n_years_diff == 1`), and lowest obsv wind threshold.

```{python}
plot_selected_threshs(13136)
```

```{python}
disp_selected_threshs(13136)
```

### Option 4

Taking the maximum impact just ends up with option 4 again

```{python}
df_metrics_reasonable_bestimpact = df_metrics_reasonable[
    df_metrics_reasonable["Total Affected"] >= 2.55e7
]
```

```{python}
df_metrics_reasonable_bestimpact
```

```{python}
plot_selected_threshs(321972)
```

```{python}
disp_selected_threshs(321972)
```
